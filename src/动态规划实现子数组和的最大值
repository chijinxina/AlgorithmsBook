/*
*问题：输入一个整型数组，数组里有正数也有负数。数组中一个或连续的多个整数组成一个子数组。
*求所有子数组的和的最大值。要求时间负责度为O(n)。
*使用动态规划方法来实现：
*如果用函数f(i)表示以第i个数字结尾的子数组的最大和，那么我们需要求出max(f[0...n])。
*我们可以给出如下递归公式求f(i)
*     |-- array[i] 如果i==0或者f(i-1)<0
*f(i)=|
*     |-- f(i-1) + array[i] 如果f(i-1)>0
*这个公式的意义：
*   当以第(i-1)个数字为结尾的子数组中所有数字的和f(i-1)小于0时，如果把这个负数和第i个数相加，得到的结果反而不第i个数本身还要小，所以这种情况下最大子数组和是第i个数本身。
*   如果以第(i-1)个数字为结尾的子数组中所有数字的和f(i-1)大于0，与第i个数累加就得到了以第i个数结尾的子数组中所有数字的和。
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
using namespace std;

int maxSumInSubArray(int *array,int len)
{
    int *c = new int[len];//用来记录以当前元素结尾（数组就到当前元素的位置为止）的子数组的最大和
    int max = -1000;//用来记录数组c[]中的最大值
    int start = 0;//记录数组中子数组的最大和的开始位置
    int end = 0;//记录数组中子数组的最大和的结束位置
    int tmp = 0;

    c[0] = array[0];
    for(int i = 1;i < len;++i)
    {
        if(c[i-1] > 0)
        {
            c[i] = c[i-1] + array[i];
        }
        else
        {
            c[i] = array[i];
            tmp = i;
        }
        if(c[i] > max)
        {
            max = c[i];
            start = tmp;
            end = i;
        }
    }
    cout<<"子数组最大和的起始位置："<<start<<"~"<<end<<endl;
    return max;
}

int main(int args,char ** argv)
{
    int array[] = {1,-2,3,10,-4,7,2,-5};
    int len = sizeof(array)/sizeof(int);
    int res = maxSumInSubArray(array,len);
    cout<<"子数组最大和: "<<res<<endl;
    system("pause");
    return 0;
}

#2. 
某幢大楼有100层。你手里有两颗一模一样的玻璃珠。当你拿着玻璃珠在某一层往下扔的时候，一定会有两个结果，玻璃珠碎了或者没碎。
这幢大楼有个临界楼层。低于它的楼层，往下扔玻璃珠，玻璃珠不会碎，等于或高于它的楼层，扔下玻璃珠，玻璃珠一定会碎。
玻璃珠碎了就不能再扔。现在让你设计一种方式，使得在该方式下，最坏的情况扔的次数比其他任何方式最坏的次数都少。也就是设计一种最有效的方式。
例如：有这样一种方式，第一次选择在60层扔，若碎了，说明临界点在60层及以下楼层，这时只有一颗珠子，剩下的只能是从第一层，一层一层往上实验，
最坏的情况，要实验59次，加上之前的第一次，一共60次。若没碎，则只要从61层往上试即可，最多只要试40次，加上之前一共需41次。
两种情况取最多的那种。故这种方式最坏的情况要试60次。仔细分析一下。如果不碎，我还有两颗珠子，第二颗珠子会从N+1层开始试吗？
很显然不会，此时大楼还剩100-N层，问题就转化为100-N的问题了。
那该如何设计方式呢？
根据题意很容易写出状态转移方程：N层楼如果从n层投下玻璃珠，最坏的尝试次数是：max(n, F(N-n)+1)
那么所有层投下的最坏尝试次数的最小值即为问题的解：
F(N) = min( min(1, 1+F(N-1)) , max(2, 1+F(N-2)), .... , max(n, 1+F(N-n)),....,max(N-1, 1+F(1)) )
其中F(1)=1.
